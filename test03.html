<script>
/**
 * @param {string} str
 * @return {number}
 */
// var myAtoi = function(str) {

//     let len = str.length;

//     if (len === 0) {  
//         return 0;
//     }

//     //寻找str的第一个非空字符

//     let p = 0;

//     while (str[p] === ' ' && p < len) {
//         p ++;
//     }

//     if (p === len) {  //说明str仅包含空白字符
//         return 0;
//     }

//     let firstNonSpaceChar = str[p];

//     if (!isNumber(firstNonSpaceChar)) {
//         return 0;
//     }

//     let pEnd = p;

//     while (isNumber(str[pEnd])) {
//         pEnd ++;
//     }

//     return parseInt(str.slice(p, pEnd));
// };

// function isNumber (ch) {
// 	ch = ch + '';
//     return ch.charCodeAt() >= 48 && ch.charCodeAt() <= 57;
// }

// myAtoi("42");


//  //如果第一个非空字符是正负号
//     let sign;
//     if (str[p] === '+') {
//         sign = 1;
//         p ++;
//     }
//     if (str[p] === '-') {
//         sign = -1;
//         p ++;
//     }


//     let firstNonSpaceChar = str[p];

// 	if (!isNumber(firstNonSpaceChar)) {
// 	    return 0;
// 	}

/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */

// var strStr = function(haystack, needle) {
//     let len1 = haystack.length,
//         len2 = needle.length;
    
//     if (len2 === 0) {
//         return 0;
//     }

//     if (len1 < len2) {
//         return -1;
//     }

//     let index,j;
//     for (let i = 0; i < len1; i ++) {
//         console.log('i: ' + i);
// 		index = i;
//         j = 0;
//         while (needle[j] === haystack[index] && j < len2) {
//             index ++;
//             j ++;
//         }

//         console.log('j: ' + j);
// 		// console.log('i(after): ' + i);
//         if (j === len2) {
//             return index - len2;
//         }
//     }
	
//     return -1;

// };

// var getPrefixTable = function (s) {
//     s = s + '';
//     let len = s.length;

//     let count = len - 1;
	
// 	let p = 0,
// 	q = len - count;
	
	

//     for (let index = 0; index <= count; index++) {
        

//         while (s[p] === s[q]) {
//             p ++;
//             q ++;
//         }

//         if (p === count-1) {  
//             return count;
//         } else {
//             count --;
//         }
//     }
	
//     return 0;
// }

// var countAndSay = function(n) {
//     if (n === 1) {
//         return '1';
//     }
//     return getNByFormer(countAndSay(n-1));
// };

// var getNByFormer = function (former) {
//     former += '';
	
// 	if (former === '1') {
// 		return '11';
// 	}
	
//     let res = '';

//     let p = 0,
//         q = 1,
//         count,
//         ch;

//     while (q < former.length) {
//         ch = former[p];
//         count = 1;
//         q = p + 1;
//         while (former[q] === former[p]) {
//             count++;
//             q ++;
//         }
//         res += count;
//         res += ch;
//         p = q;
//     }

//     return res;
    
// }

// /**
//  * @param {character[][]} grid
//  * @return {number}
//  */
//  var numIslands = function(grid) {
//     let count = 0;
//     for (let i = 0; i < grid.length; i++) {
//         for (let j = 0; j < grid[0].length; j++) {
//             if (grid[i][j] === '1') {
//                 islandBFS(grid,i,j);
//                 count ++;
//             }
//         }
//     }

//     return count;
// };

// var islandBFS = function(grid, i, j) {
//     //建立一个队列，存储访问的结点(i,j)

//     let queue = [];

//     //(i,j)构成一个结点
//     let node = [];
//     node.push(i);
//     node.push(j);
//     queue.push(node);
//     grid[i][j] = '0';

//     while (queue.length > 0) {  //只要队列中还有元素


//         let queueNode = queue.shift();
//         let i = queueNode[0];
//         let j = queueNode[1];

//         if (i-1 >= 0 && grid[i-1][j] === '1') {  //看上面有没有没有访问过的元素
//             let node = [];
//             node.push(i-1);
//             node.push(j);
//             queue.push(node);
//             grid[i-1][j] = '0';
//         }

//         if (i+1 < grid.length && grid[i+1][j] === '1') {  //看下面有没有没有访问过的元素
//             let node = [];
//             node.push(i+1);
//             node.push(j);
//             queue.push(node);
//             grid[i+1][j] = '0';
//         }

//         if (grid[i][j-1] === '1') {  //看左面有没有没有访问过的元素
//             let node = [];
//             node.push(i);
//             node.push(j-1);
//             queue.push(node);
//             grid[i][j-1] = '0';
//         }

//         if (grid[i][j+1] === '1') {  //看右面有没有没有访问过的元素
//             let node = [];
//             node.push(i);
//             node.push(j+1);
//             queue.push(node);
//             grid[i][j+1] = '0';
//         }
//     }
// }

// var islandsDFS = function(grid, i, j) {
//     //建立一个堆栈，存储访问的节点
//     let stack = [];

//     //(i,j)构成一个结点
//     let node = [];
//     node.push(i);
//     node.push(j);
//     stack.push(node);
//     grid[i][j] = '0';

//     while (stack.length > 0) {

//         let stackNode = stack[stack.length-1];
//         let i = stackNode[0];
//         let j = stackNode[1];
//         // console.log('(i,j): ' + '(' + i + ', ' + j +')');
//         if (i - 1 >= 0 && grid[i-1][j] === '1') {
//             let node = [];
//             node.push(i-1);
//             node.push(j);
//             stack.push(node);
//             grid[i-1][j] = '0';
//             console.log('(i-1,j): ' + '(' + (i-1) + ', ' + j +')');
//         } else if (i + 1 < grid.length && grid[i+1][j] === '1') {
//             let node = [];
//             node.push(i+1);
//             node.push(j);
//             stack.push(node);
//             grid[i+1][j] = '0';
//             console.log('(i+1,j): ' + '(' + (i+1) + ', ' + j +')');
//         } else if (grid[i][j-1] === '1') {
//             let node = [];
//             node.push(i);
//             node.push(j-1);
//             stack.push(node);
//             grid[i][j-1] = '0';
//             console.log('(i,j-1): ' + '(' + i + ', ' + (j-1) +')');
//         } else if (grid[i][j+1] === '1') {
//             let node = [];
//             node.push(i);
//             node.push(j+1);
//             stack.push(node);
//             grid[i][j+1] = '0';
//             console.log('(i,j+1): ' + '(' + i + ', ' + (j+1) +')');
//         } else {
//             stack.pop();
//         }   
//     }

// }

// function dfs(grid, r, c) {

//         let nr = grid.length;
//         let nc = grid[0].length;

//         if (r < 0 || c < 0 || r >= nr || c >= nc || grid[r][c] == '0') {
//             return;
//         }

//         console.log('(i,j): ' + '(' + r + ', ' + c +')');
//         grid[r][c] = '0';

//         dfs(grid, r - 1, c);
//         dfs(grid, r + 1, c);
//         dfs(grid, r, c - 1);
//         dfs(grid, r, c + 1);
// }



// var arr = [
// ['1','1','1','1','0'],
// ['1','1','0','1','0'],
// ['1','1','0','0','0'],
// ['0','0','0','0','0']
// ];

// // islandBFS(arr,0,0); 

// var arr1 = [
// ['1','1','0','0','0'],
// ['1','1','0','0','0'],
// ['0','0','1','0','0'],
// ['0','0','0','1','1']
// ];

// // islandBFS(arr1,0,0); 

// var arr2 = [["1","1","1"],["0","1","0"],["1","1","1"]];

// var arr3 = [["1","1","1"],["0","1","0"],["0","1","0"]];

// var getNextArr = function(s, deadends) {
//     //经过一次移动，能够达到的状态
//     let arr = [];
//     let str = '';

//     for (let i = 0; i < 4; i++) {
//         let chArr = s.split('');
//         chArr[i] = ((parseInt(chArr[i]) + 1) % 10) + '';
//         str = chArr.join('');
//         if (!containsInDeadends(str,deadends)){
//             arr.push(str);
//         }
//         chArr = s.split('');
//         chArr[i] = ((parseInt(chArr[i]) - 1 + 10) % 10) + '';
//         str = chArr.join('');
//         if (!containsInDeadends(str,deadends)){
//             arr.push(str);
//         }
//     }

//     return arr;
// }

// var containsInDeadends = function(str, arr) {
//     for (let i = 0; i < arr.length; i++) {
//         if (arr[i] === str) {
//             return true;
//         }
//     }
//     return false;
// }

// console.log(getNextArr("0202", ["0201","0101","0102","1212","2002"]));



/**
 * @param {string[]} deadends
 * @param {string} target
 * @return {number}
 * 你有一个带有四个圆形拨轮的转盘锁。
 * 每个拨轮都有10个数字
 * 每个拨轮可以自由旋转
 * 锁的初始数字为 '0000' ，一个代表四个拨轮的数字的字符串。
 * 列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。
 * 字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。
 */
//  var openLock = function(deadends, target) {
//     //设置一个队列
//     let queue = [];

//     if (containsInArr('0000', deadends)) {
//         return -1;
//     } else {
//         //初始化
//         queue.push('0000');
//         queue.push(null);
//     }

//     let depth = 0,
//         visited = new Map();

//     while (queue.length > 0) {
//         let str = queue.shift();
//         if (str === null) {
//             depth ++;
//             if (queue[queue.length - 1] != null) {
//                 queue.push(null);
//             }
//         } else if (strEqual(str, target)) {
//             return depth;
//         } else {
//             let arr = getNextArr(str, deadends);
//             console.log(arr);
//             for (let item of arr) {
//                 if (!visited.get(item)) {
//                     visited.set(item, true);
//                     queue.push(item);
//                 }
//             }
//         }
//     }

//     return -1;
// };



// var getNextArr = function(s, deadends) {
//     //经过一次移动，能够达到的状态
//     let arr = [];
//     let str = '';

//     for (let i = 0; i < 4; i++) {
//         let chArr = s.split('');
//         chArr[i] = ((parseInt(chArr[i]) + 1) % 10) + '';
//         str = chArr.join('');
//         if (!containsInArr(str,deadends)){
//             arr.push(str);
//         }
//         chArr = s.split('');
//         chArr[i] = ((parseInt(chArr[i]) - 1 + 10) % 10) + '';
//         str = chArr.join('');
//         if (!containsInArr(str,deadends)){
//             arr.push(str);
//         }
//     }

//     return arr;
// }

// var containsInArr = function(str, arr) {
//     for (let i = 0; i < arr.length; i++) {
//         if (arr[i] === str) {
//             return true;
//         }
//     }
//     return false;
// }

// var strEqual = function (str1, str2) {
//     if (str1.length != str2.length) {
//         return false;
//     }

//     for (let i = 0; i < str1.length; i++) {
//         if (str1[i] !== str2[i]) {
//             return false;
//         }
//     }

//     return true;
// }

// // let deadends = ["0201","0101","0102","1212","2002"];
// // let target = "0202";

// let deadends = ["0000"];
// let target = "8888";

// deadends = ["8888"]
// target = "0009"
// deadends = ["8887","8889","8878","8898","8788","8988","7888","9888"]
// target = "8888"

// function A () {
//     let content = [];
// }

// A.prototype.push = function (x) {
//     content[content.length] = x;
// }


/**
 * @param {string} s
 * @return {boolean}
 */
// var isValid = function(s) {

// let len = s.length;

// if (len === 0) {
//     return true;
// }

// let symbols = ['(',')','[',']','{','}'];

// let stack = [];

// for (let i = 0; i < len; i ++) {

//     if (s[i] === symbols[0] || s[i] === symbols[2] || s[i] === symbols[4]) {
//         stack.push(s[i]);
        
//     } else if (s[i] === symbols[1]) {
//         if (stack.pop() !== s[0]) {
//             return false;
//         }
//     } else if (s[i] === symbols[3]) {
//         if (stack.pop() !== s[2]) {
//             return false;
//         }
//     } else if (s[i] === symbols[5]) {
//         if (stack.pop() !== s[4]) {
//             return false;
//         }
//     } else {
        
//         return false;
        
//     }
// }

// return true;
// };

/**
 * @param {string} s
 * @return {boolean}
 */
// var isValid = function(s) {

// let len = s.length;

// if (len % 2 === 1) {
//     return false;
// }

// //存储括号的映射关系
// let relations = new Map([
//     ['(',')'],
//     ['[',']'],
//     ['{','}']
// ]);

// let stack = [],
//     result = true;

// var temp = s.split('').map(ch => {
//     if (relations.has(ch)) {
//         stack.push(ch);
//     } else {
//         console.log(ch);
//         console.log(relations.get(stack.pop()));
//         console.log(relations.get(stack.pop()) !== ch);


//         if (relations.get(stack.pop()) !== ch) {
//             console.log('test');
//             return false;
//         }
        
//     }
// });

// console.log(stack.length);
// return temp;
// return !stack.length;

// };

// var arr = [1,2,3,4];

// function test (arr) {

//     var arr1 = arr.map((x)=>{
//         if (x > 2) {
//             return true;
//         }});
//     console.log('test');
//     return arr1;
// }

//  var isValid = function(s) {
//     const n = s.length;
//     if (n % 2 === 1) {
//         return false;
//     }
//     const pairs = new Map([
//         [')', '('],
//         [']', '['],
//         ['}', '{']
//     ]);
//     const stk = [];
//     s.split('').forEach(ch => {
//         if (pairs.has(ch)) {
//             if (!stk.length || stk[stk.length - 1] !== pairs.get(ch)) {
//                 return false;
//             }
//             stk.pop();
//         } 
//         else {
//             stk.push(ch);
//         }
//     });
//     console.log(stk.length);
//     return !stk.length;
// };

// var isValid = function(s) {
//     const n = s.length;
//     if (n % 2 === 1) {
//         return false;
//     }
//     const pairs = new Map([
//         [')', '('],
//         [']', '['],
//         ['}', '{']
//     ]);
//     const stk = [];
//     s.split('').forEach(ch => {
//         if (pairs.has(ch)) {
//             if (!stk.length || stk[stk.length - 1] !== pairs.get(ch)) {
//                 return false;
//             }
//             stk.pop();
//         } 
//         else {
//             stk.push(ch);
//         }
//     });
//     return !stk.length;
// };


// var isValid = function(s) {
//     const n = s.length;
//     if (n % 2 === 1) {
//         return false;
//     }
//     const pairs = new Map([
//         [')', '('],
//         [']', '['],
//         ['}', '{']
//     ]);
//     const stk = [];
//     s.split('').forEach(ch => {
//         if (pairs.has(ch)) {
//             if (!stk.length || stk[stk.length - 1] !== pairs.get(ch)) {
//                 return false;
//             }
//             stk.pop();
//         } 
//         else {
//             stk.push(ch);
//         }
//     });
//     return !stk.length;
// };
//var s = ["-8","23","8","-","9","23","-","-","*","33","-8","/","+","38","-14","-","-","-7","32","-19","-","11","+","+","+","14","22","-","-","27","-9","-","+","31","+","-12","-11","-","-","14","+","30","+","37","30","-","+","-9","+","7","-","37","+","-5","13","/","-","19","-2","-19","12","+","-","23","+","-","-19","-","+","6","+","-17","+","17","+","5","36","+","-10","+","+","23","-8","-","-","18","-","31","-16","-","+","34","+","-6","+","24","-","22","-","-8","-","28","+","-12","+","39","28","-7","+","+","-14","5","+","5","+","10","+","+","+","-18","*","10","+","-5","11","-","6","+","-","-12","31","+","+","30","29","-","-","39","+","13","-8","-5","+","-","26","19","-","*","-","10","-","-20","5","+","+","0","-","28","-","19","/","28","+","-18","-","28","20","+","-5","-19","+","+","-","-12","-","3","-","6","-15","+","4","-","-","38","+","-9","-","38","-","12","-20","-","10","5","-15","-","-","-","+","-11","+","5","+","2","-","28","+","-9","-11","-","+","37","-","-17","31","-","2","+","+","-16","-12","-","-","12","+","34","-","15","+","8","+","17","-","2","-","33","+","-5","+","14","+","29","-","33","23","+","26","30","-","+","+","39","+","9","24","-","-","20","15","+","-","24","+","37","-","30","-1","-","+","34","+","-13","-","23","15","-","-","-5","-8","8","30","35","-9","22","+","-","-","36","-1","+","5","-","-","+","25","-","+","27","-","16","+","+","+","39","-","15","-","-3","+","5","-6","-","+","-6","-15","-7","-","+","/","13","-","18","+","4","+","29","+","-17","0","-6","-20","-17","+","12","-","+","-","+","+","-10","22","+","+","-11","-","-2","38","-","-","-6","+","0","-","-10","+","-4","-10","+","-","0","-","31","30","-","37","5","+","+","+","-15","+","38","4","-","-16","-17","+","+","+","38","-","27","-19","/","12","+","/"];

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 * 给定一个二叉树，返回它的中序 遍历。
 */
// var inorderTraversal = function(root) {
//     let res = [];
//     function recurse (index) {
//         if (!root[index]) {
//             return;
//         }
//         recurse(index + 1);
//         res.push(root[index]);
//         recurse(index + 2);
//     }
//     recurse(0);
//     return res;
// };
/**
 * @param {string} s
 * @return {string}
 */
//  var decodeString = function(s) {
//     let numberStack = [],
//         charStack = [],
//         res = '';
    
//     for (let i = 0; i < s.length; i ++) {
//         let ch = s[i];

//         if (!isNaN(ch)) {  //ch是数字类型
//             let num = '';
//             while(!isNaN(s[i])) {
//                 console.log(s[i]);
//                 num += s[i];
//                 i ++;
//             }
//             i --;
//             numberStack.push(num);
//         } else {
//             if (ch !== ']') {
//                 charStack.push(ch);
//             } else {
//                 let count = parseInt(numberStack.pop()),
//                     str = '',
//                     index = charStack.length - 1;
                
//                 while (charStack[index] != '[') {
//                     str += charStack[index];
//                     index --;
//                 }

//                 str = str.split('').reverse().join('');

//                 for (let i = index + 1; i < charStack.length; i++){
//                     charStack[i-1] = charStack[i];
//                 }

//                 charStack.length --;
//                 count --;

//                 while (count > 0) {
//                     console.log(count);
//                     charStack.push(str);
//                     // str.split('').forEach(x => {charStack.push(x)});
//                     count--;
//                 }
//             }
//         }
//     }

//     return charStack.join('');

// };

// function Find(target, array)
// {
//     // write code here
//     let len1 = array.length;
//     if (len1 === 0) return false;
//     let len2 = array[0].length;
//     if (len2 === 0) return false;
    
//     //获取左下角的元素
//     let i = len1 - 1,
//         j = 0;
    
//     while (i >= 0 && j <= len2 - 1) {
//         if (array[i][j] === target) {
//             return true;
//         } else if (array[i][j] < target) {
//             j ++;
//         } else {
//             i --;
//         }
//     }
    
//     return false;
// }

// let arr = [
//     [1,2,3],
//     [4,5,6],
//     [7,8,9]
// ];

// let target = 3;

// console.log(Find(3,arr));
// function TreeNode(val) {
//      this.val = val;
//      this.left = this.right = null;
// }

// var buildTree = function(preorder, inorder) {
//     return buildTreeByArrs(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);
// };

// var buildTreeByArrs = function (preorder, pre_left, pre_right, inorder, inorder_left, inorder_right) {
	
// 	// console.log('*');
	
//     if (pre_left > pre_right) {
//         return null;
//     }


//     let root = new TreeNode(preorder[pre_left]);
	
// 	// console.log(pre_left);

//     let index = inorder_left;

//     while (inorder[index] != preorder[pre_left]) {
//         index ++;
//     }
	
// 	console.log("x");
//     root.left = buildTreeByArrs(preorder, pre_left + 1, pre_left + index - inorder_left, 
//                                 inorder, inorder_left, index-1);
    
	
	
//     root.right = buildTreeByArrs(preorder, pre_right - inorder_right + index + 1, pre_right, 
//                                 inorder, index + 1, inorder_right);
    
//     return root;
// }
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

// function TreeNode(val) {
//      this.val = val;
//      this.left = this.right = null;
// }
// /**
//  * @param {number[]} preorder
//  * @param {number[]} inorder
//  * @return {TreeNode}
//  */
// var buildTree = function(preorder, inorder) {
//     let map = new Map();
//     for (let i = 0; i < inorder.length; i ++) {
//         map.set(inorder[i],i);
//     }
	
//     return buildTreeByArrs(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1, map);
// };

// var buildTreeByArrs = function (preorder, pre_left, pre_right, inorder, inorder_left, inorder_right, map) {
	
// 	console.dir(map);
	
//     if (pre_left > pre_right) {
//         return null;
//     }


//     let root = new TreeNode(preorder[pre_left]);

//     let index = map.get(preorder[pre_left]);

//     root.left = buildTreeByArrs(preorder, pre_left + 1, pre_left + index - inorder_left, 
//                                 inorder, inorder_left, index-1, map);
    
//     root.right = buildTreeByArrs(preorder, pre_right - inorder_right + index + 1, pre_right, 
//                                 inorder, index + 1, inorder_right, map);
    
//     return root;
// }



/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */


/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
// var buildTree = function(preorder, inorder) {

//     if (preorder.length === 0) {
//         return null;
//     }

//     let root = new TreeNode(preorder[0]);
//     let stack = [],
//         inorderIndex = 0;

//     stack.push(root);

//     for (let i = 1; i < preorder.length; i++) {

//         let preorderValue = preorder[i];

//         let curNode = new TreeNode(preorderValue);

//         let topElement = stack[stack.length-1];
		
// 		// console.log("topElement: " + topElement.val);
// 		// console.log("inorderIndex: " + inorderIndex);
// 		// console.log("inorder[inorderIndex]: " + inorder[inorderIndex]);
// 		// console.log(typeof inorder[inorderIndex]);
// 		// console.log(typeof topElement);
// 		// console.log("--------------------------")

//         if (inorder[inorderIndex] !== topElement.val) {
//             topElement.left = curNode;
//         } else {
// 			// console.log("x");
// 			// console.log(stack.length);
// 			// console.log(stack[stack.length-1])
// 			let node;
//             while (stack.length !== 0 && stack[stack.length-1].val === inorder[inorderIndex]) {
// 				console.log('x');
//                 node = stack.pop();
//                 inorderIndex ++;
//             }
//             node.right = curNode;
//         }
//         stack.push(curNode);
//     }

//     return root;
// };

// var v = buildTree([3,9,20,15,7], [9,3,15,20,7]);

// function SuperType() {
//     this.property = true;
// }

// SuperType.prototype.getSuperValue = function() {
//     return this.property;
// }

	function delEl(arr,index) {
		for (let i = index; i <= arr.length-2; i++) {
			console.log("i: " + i);
			arr[i] = arr[i+1];
			
		}
		arr.length--;
	}
	
	var arr = [1,2,3,4];

</script>